#!/usr/bin/env ruby

require 'optparse'
require 'set'

# Backport for Ruby < 2.4
class Enumerator::Lazy
  unless instance_methods.include?(:uniq)
    def uniq
      elems = Set.new
      select do |elem|
        val = block_given? ? yield(e) : e
        if set.include?(val)
          false
        else
          elems << val
          true
        end
      end
    end
  end
end

Options = Struct.new(:interactive, :num)

def parse_args(args)
  options = Options.new(false, 5)
  OptionParser.new do |opts|
    opts.on('-i', '--interactive', 'Interactively choose a branch to switch to') do
      options.interactive = true
    end

    opts.on('-n VAL', '--num=VAL', Integer, 'Number of recent branches to display') do |val|
      options.num = val
    end

    opts.on('-h', '--help', 'Display this help') do |val|
      puts opts
      exit 0
    end
  end.parse!(args)
  options.freeze
end

def verify_is_git_repo!
  system('git rev-parse --is-inside-work-tree >/dev/null') or exit $?.to_i
end

def current_branch
  name = `git rev-parse --abbrev-ref HEAD`.strip
  if $?.success?
    name
  else
    exit $?.to_i
  end
end

def recent_branches(num)
  reflog = IO.popen('git reflog')
  branch_list = IO.popen(%q(git for-each-ref --format='%(refname:short)' refs/heads/))
  current_branch = current_branch()

  all_branches = branch_list.readlines.map(&:strip).to_set

  reflog.readlines.lazy.flat_map do |line|
    match = line.match(/moving from (\S+) to (\S+)/)
    match && match.captures || []
  end.select do |branch|
    all_branches.include?(branch)
  end.reject do |branch|
    branch == current_branch
  end.uniq.take(num)
end

def run!
  options = parse_args(ARGV.dup)

  verify_is_git_repo!
  recent_branches = recent_branches(options.num)

  if options.interactive
    recent_branches.to_a.each.with_index do |branch, i|
      puts "#{i + 1}) #{branch}"
    end

    print 'Choose a branch to switch to: '
    branch_num = Integer($stdin.gets)
    branch = recent_branches.to_a[branch_num - 1]
    system "git checkout #{branch}"
  else
    puts recent_branches.to_a
  end
end

trap = proc do
  puts
  exit 1
end

Signal.trap('SIGINT', trap)
Signal.trap('SIGTERM', trap)

run!
