#!/usr/bin/env ruby

require 'optparse'
require 'set'

module Enumerable
  def take_uniq n
    raise ArgumentError, 'attempt to take negative size' if n < 0
    return [] if n == 0

    each.with_object(Set.new) do |elem, elems|
      elems << elem
      break elems if elems.size == n
    end
  end
end

Options = Struct.new(:interactive, :num)

def parse_args(args)
  options = Options.new(false, 5)
  OptionParser.new do |opts|
    opts.on('-i', '--interactive', 'Interactively choose a branch to switch to') do
      options.interactive = true
    end

    opts.on('-n VAL', '--num=VAL', Integer, 'Number of recent branches to display') do |val|
      options.num = val
    end

    opts.on('-h', '--help', 'Display this help') do |val|
      puts opts
      exit 0
    end
  end.parse!(args)
  options.freeze
end

def verify_is_git_repo!
  system('git rev-parse --is-inside-work-tree >/dev/null') or exit $?.to_i
end

def recent_branches(num)
  reflog = IO.popen('git reflog')
  branch_list = IO.popen(%q(git for-each-ref --format='%(refname:short)' refs/heads/))

  all_branches = branch_list.readlines.map(&:strip).to_set

  reflog.readlines.lazy.flat_map do |line|
    match = line.match(/moving from (\S+) to (\S+)/)
    branches = match && match.captures || []
    branches.select { |branch| all_branches.include? branch }
  end.take_uniq(num)
end

def run!
  options = parse_args(ARGV.dup)

  verify_is_git_repo!
  recent_branches = recent_branches(options.num)

  if options.interactive
    recent_branches.to_a.each.with_index do |branch, i|
      puts "#{i + 1}) #{branch}"
    end

    print 'Choose a branch to switch to: '
    branch_num = Integer($stdin.gets)
    branch = recent_branches.to_a[branch_num - 1]
    system "git checkout #{branch}"
  else
    puts recent_branches.to_a
  end
end

trap = proc do
  puts
  exit 1
end

Signal.trap('SIGINT', trap)
Signal.trap('SIGTERM', trap)

run!
